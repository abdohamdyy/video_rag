from __future__ import annotations

import logging
import time
import uuid
from typing import Any, Dict, Optional

from fastapi import FastAPI, File, Form, HTTPException, UploadFile
from fastapi.exceptions import RequestValidationError
from fastapi.requests import Request
from fastapi.responses import JSONResponse

from app.gemini_video_understanding import GeminiAPIError, analyze_video_with_gemini
from app.settings import get_settings
from app.video_io import VideoDownloadError, VideoTooLargeError, download_video, read_upload
from app.question_generation import (
    extract_user_questions,
    generate_clarifying_questions,
    build_retrieval_queries,
)
from app.rag_orchestrator import (
    retrieve_support_docs,
    compose_grounded_prompt,
    answer_with_gemini,
)


app = FastAPI(title="Video Understanding API", version="0.1.0")
logger = logging.getLogger("video_understanding_api")


@app.exception_handler(RequestValidationError)
async def request_validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """
    FastAPI's default validation handler may fail to JSON-encode some `input` values
    (e.g., UploadFile objects) which can cause an unintended 500 error.
    This handler sanitizes the error payload and returns a proper 422 response.
    """
    errors = exc.errors()
    for err in errors:
        if "input" in err:
            try:
                err["input"] = str(err["input"])
            except Exception:  # noqa: BLE001
                err.pop("input", None)

    # Special-case a common user mistake: sending an uploaded file under the `video_url` field.
    for err in errors:
        loc = err.get("loc") or ()
        if tuple(loc) == ("body", "video_url") and "UploadFile(" in str(err.get("input", "")):
            return JSONResponse(
                status_code=400,
                content={
                    "detail": "Invalid form field: you uploaded a file under 'video_url'. "
                    "Use 'video_file' for uploads, or send 'video_url' as a plain string URL.",
                    "errors": errors,
                },
            )

    logger.warning("event=request_validation_error path=%s errors=%s", request.url.path, errors)
    return JSONResponse(status_code=422, content={"detail": errors})


@app.get("/health")
async def health() -> Dict[str, str]:
    return {"status": "ok"}


@app.post("/video/analyze")
async def video_analyze(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Accepts either:
    - multipart file: video_file
    - or a URL: video_url
    Returns a structured JSON analysis generated by Gemini.
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        logger.info(
            "request_id=%s event=video_received source=%s mime_type=%s bytes=%d model=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
        )

        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
        )

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=analysis_completed elapsed_ms=%d", request_id, elapsed_ms)

        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "model": chosen_model,
                "video_source": payload.source,
                "video_mime_type": payload.mime_type,
                "analysis": result.data,
                "transcript": (result.data or {}).get("transcript", ""),
                "raw_text": result.raw_text,
            },
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        # Preserve upstream error semantics instead of returning a generic 500.
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/assist/video")
async def assist_video(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Full assistance pipeline:
    1) Analyze video with Gemini to extract appliance/brand/issue/transcript
    2) Generate questions (extracted + clarifying)
    3) Retrieve support docs from Chroma (BGE-M3 embeddings)
    4) Ask Gemini to produce a grounded, actionable answer
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        logger.info(
            "request_id=%s event=assist_video_received source=%s mime_type=%s bytes=%d model=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
        )

        # 1) Video analysis
        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
        )
        analysis = result.data or {}
        transcript = analysis.get("transcript", "") or ""

        # 2) Questions
        user_questions = extract_user_questions(transcript)
        clarifying_questions = generate_clarifying_questions(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            language=language,
        )
        # 3) Retrieval
        queries = build_retrieval_queries(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            user_questions=user_questions,
        )
        citations = retrieve_support_docs(queries)

        # 4) Grounded answer
        grounded_prompt = compose_grounded_prompt(
            transcript=transcript,
            analysis=analysis,
            clarifying_questions=clarifying_questions,
            citations=citations,
            language=language,
        )
        answer = answer_with_gemini(
            api_key=settings.gemini_api_key,
            model=settings.gemini_answer_model,
            prompt=grounded_prompt,
        )

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=assist_pipeline_completed elapsed_ms=%d", request_id, elapsed_ms)

        # Prefer follow-up from analysis if any; otherwise suggest clarifying questions
        follow_ups = analysis.get("questions_to_confirm") or clarifying_questions

        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "model_video": chosen_model,
                "model_answer": settings.gemini_answer_model,
                "video_source": payload.source,
                "video_mime_type": payload.mime_type,
                "analysis": analysis,
                "transcript": transcript,
                "user_questions": user_questions,
                "clarifying_questions": clarifying_questions,
                "retrieval": {"citations": citations},
                "answer": {
                    "text": answer.get("text", ""),
                    "follow_up_questions": follow_ups,
                },
                "raw_text_video": result.raw_text,
            },
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e

