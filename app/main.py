from __future__ import annotations

import base64
import logging
import time
import uuid
from typing import Any, Dict, Optional

from fastapi import FastAPI, File, Form, HTTPException, UploadFile
from fastapi.exceptions import RequestValidationError
from fastapi.requests import Request
from fastapi.responses import JSONResponse

from app.elevenlabs_tts import ElevenLabsTTSError, text_to_speech_wav
from app.gemini_video_understanding import GeminiAPIError, analyze_video_with_gemini
from app.settings import get_settings
from app.video_io import VideoDownloadError, VideoTooLargeError, download_video, read_upload
from app.question_generation import (
    extract_user_questions,
    generate_clarifying_questions,
    build_retrieval_queries,
)
from app.rag_orchestrator import (
    retrieve_support_docs,
    compose_grounded_prompt,
    answer_with_gemini,
)


app = FastAPI(title="Video Understanding API", version="0.1.0")
logger = logging.getLogger("video_understanding_api")


@app.exception_handler(RequestValidationError)
async def request_validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """
    FastAPI's default validation handler may fail to JSON-encode some `input` values
    (e.g., UploadFile objects) which can cause an unintended 500 error.
    This handler sanitizes the error payload and returns a proper 422 response.
    """
    errors = exc.errors()
    for err in errors:
        if "input" in err:
            try:
                err["input"] = str(err["input"])
            except Exception:  # noqa: BLE001
                err.pop("input", None)

    # Special-case a common user mistake: sending an uploaded file under the `video_url` field.
    for err in errors:
        loc = err.get("loc") or ()
        if tuple(loc) == ("body", "video_url") and "UploadFile(" in str(err.get("input", "")):
            return JSONResponse(
                status_code=400,
                content={
                    "detail": "Invalid form field: you uploaded a file under 'video_url'. "
                    "Use 'video_file' for uploads, or send 'video_url' as a plain string URL.",
                    "errors": errors,
                },
            )

    logger.warning("event=request_validation_error path=%s errors=%s", request.url.path, errors)
    return JSONResponse(status_code=422, content={"detail": errors})


@app.get("/health")
async def health() -> Dict[str, str]:
    return {"status": "ok"}


@app.post("/video/analyze")
async def video_analyze(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Accepts either:
    - multipart file: video_file
    - or a URL: video_url
    Returns a structured JSON analysis generated by Gemini.
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        logger.info(
            "request_id=%s event=video_received source=%s mime_type=%s bytes=%d model=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
        )

        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
        )

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=analysis_completed elapsed_ms=%d", request_id, elapsed_ms)

        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "model": chosen_model,
                "video_source": payload.source,
                "video_mime_type": payload.mime_type,
                "analysis": result.data,
                "transcript": (result.data or {}).get("transcript", ""),
                "raw_text": result.raw_text,
            },
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        # Preserve upstream error semantics instead of returning a generic 500.
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/assist/video")
async def assist_video(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    part_number: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Full assistance pipeline (supports both video and image):
    1) Analyze video/image with Gemini to extract appliance/brand/issue/part_number/transcript
    2) Generate questions (extracted + clarifying)
    3) Retrieve support docs from Chroma (BGE-M3 embeddings), optionally filtered by part_number
    4) Ask Gemini to produce a grounded, actionable answer
    
    Supports:
    - Video files: MP4, WebM, MOV, AVI
    - Image files: JPG, JPEG, PNG, WebP, GIF
    - Video URLs: Direct links to video files
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        # Detect if media is an image
        is_image = payload.mime_type and payload.mime_type.startswith("image/")

        logger.info(
            "request_id=%s event=assist_media_received source=%s mime_type=%s bytes=%d model=%s is_image=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
            is_image,
        )

        # 1) Media analysis (video or image)
        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
            is_image=is_image,
        )
        analysis = result.data or {}
        transcript = analysis.get("transcript", "") or ""

        # 2) Questions
        user_questions = extract_user_questions(transcript)
        clarifying_questions = generate_clarifying_questions(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            language=language,
        )
        # 3) Retrieval
        queries = build_retrieval_queries(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            user_questions=user_questions,
        )
        # Use part_number from request if provided, otherwise from video analysis
        effective_part_number = part_number if part_number and part_number.strip() else analysis.get("part_number")
        citations = retrieve_support_docs(queries, part_number=effective_part_number)

        # 4) Grounded answer
        grounded_prompt = compose_grounded_prompt(
            transcript=transcript,
            analysis=analysis,
            clarifying_questions=clarifying_questions,
            citations=citations,
            language=language,
            part_number=effective_part_number,
        )
        answer = answer_with_gemini(
            api_key=settings.gemini_api_key,
            model=settings.gemini_answer_model,
            prompt=grounded_prompt,
        )

        # 5) Generate audio from answer text
        audio_base64 = None
        audio_format = None
        if settings.elevenlabs_api_key:
            try:
                answer_text = answer.get("text", "")
                if answer_text:
                    audio_bytes, audio_format = text_to_speech_wav(
                        text=answer_text,
                        api_key=settings.elevenlabs_api_key,
                        language=language,
                    )
                    audio_base64 = base64.b64encode(audio_bytes).decode("utf-8")
                    logger.info("request_id=%s event=audio_generated format=%s", request_id, audio_format)
            except ElevenLabsTTSError as e:
                logger.warning("request_id=%s event=audio_generation_failed error=%s", request_id, str(e))
            except Exception as e:
                logger.warning("request_id=%s event=audio_generation_error error=%s", request_id, str(e))

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=assist_pipeline_completed elapsed_ms=%d", request_id, elapsed_ms)

        # Prefer follow-up from analysis if any; otherwise suggest clarifying questions
        follow_ups = analysis.get("questions_to_confirm") or clarifying_questions

        response_content: Dict[str, Any] = {
            "ok": True,
            "request_id": request_id,
            "model_video": chosen_model,
            "model_answer": settings.gemini_answer_model,
            "video_source": payload.source,
            "video_mime_type": payload.mime_type,
            "analysis": analysis,
            "transcript": transcript,
            "user_questions": user_questions,
            "clarifying_questions": clarifying_questions,
            "retrieval": {"citations": citations},
            "answer": {
                "text": answer.get("text", ""),
                "follow_up_questions": follow_ups,
            },
            "raw_text_video": result.raw_text,
        }
        
        # Add audio fields if audio was generated
        if audio_base64:
            response_content["audio_base64"] = audio_base64
            response_content["audio_format"] = audio_format or "wav"

        return JSONResponse(
            status_code=200,
            content=response_content,
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e

