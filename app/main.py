from __future__ import annotations

import base64
import logging
import time
import uuid
from typing import Any, Dict, List, Optional

from fastapi import FastAPI, File, Form, HTTPException, UploadFile
from fastapi.exceptions import RequestValidationError
from fastapi.requests import Request
from fastapi.responses import JSONResponse

from app.elevenlabs_tts import ElevenLabsTTSError, text_to_speech_wav
from app.gemini_video_understanding import GeminiAPIError, analyze_video_with_gemini
from app.settings import get_settings
from app.video_io import VideoDownloadError, VideoTooLargeError, download_video, read_upload
from app.question_generation import (
    extract_user_questions,
    generate_clarifying_questions,
    build_retrieval_queries,
)
from app.rag_orchestrator import (
    retrieve_support_docs,
    compose_grounded_prompt,
    answer_with_gemini,
)
from app.elevenlabs_knowledge_base import (
    ElevenLabsKBError,
    upload_document_with_part_number,
    list_documents,
    get_document_info,
    delete_document,
    sync_rag_index,
    create_or_get_folder_by_part_number,
    assign_knowledge_base_to_agent,
)
from app.elevenlabs_agent import (
    ElevenLabsAgentError,
    initialize_agent_with_video_context,
    create_conversation_session,
    generate_ticket_summary,
)
from app.conversation_manager import ConversationState


app = FastAPI(title="Video Understanding API", version="0.1.0")
logger = logging.getLogger("video_understanding_api")


@app.exception_handler(RequestValidationError)
async def request_validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """
    FastAPI's default validation handler may fail to JSON-encode some `input` values
    (e.g., UploadFile objects) which can cause an unintended 500 error.
    This handler sanitizes the error payload and returns a proper 422 response.
    """
    errors = exc.errors()
    for err in errors:
        if "input" in err:
            try:
                err["input"] = str(err["input"])
            except Exception:  # noqa: BLE001
                err.pop("input", None)

    # Special-case a common user mistake: sending an uploaded file under the `video_url` field.
    for err in errors:
        loc = err.get("loc") or ()
        if tuple(loc) == ("body", "video_url") and "UploadFile(" in str(err.get("input", "")):
            return JSONResponse(
                status_code=400,
                content={
                    "detail": "Invalid form field: you uploaded a file under 'video_url'. "
                    "Use 'video_file' for uploads, or send 'video_url' as a plain string URL.",
                    "errors": errors,
                },
            )

    logger.warning("event=request_validation_error path=%s errors=%s", request.url.path, errors)
    return JSONResponse(status_code=422, content={"detail": errors})


@app.get("/health")
async def health() -> Dict[str, str]:
    return {"status": "ok"}


@app.post("/video/analyze")
async def video_analyze(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Accepts either:
    - multipart file: video_file
    - or a URL: video_url
    Returns a structured JSON analysis generated by Gemini.
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        logger.info(
            "request_id=%s event=video_received source=%s mime_type=%s bytes=%d model=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
        )

        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
        )

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=analysis_completed elapsed_ms=%d", request_id, elapsed_ms)

        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "model": chosen_model,
                "video_source": payload.source,
                "video_mime_type": payload.mime_type,
                "analysis": result.data,
                "transcript": (result.data or {}).get("transcript", ""),
                "raw_text": result.raw_text,
            },
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        # Preserve upstream error semantics instead of returning a generic 500.
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/assist/video")
async def assist_video(
    video_file: Optional[UploadFile] = File(default=None),
    video_url: Optional[str] = Form(default=None),
    language: str = Form(default="ar"),
    user_hint: Optional[str] = Form(default=None),
    part_number: Optional[str] = Form(default=None),
    model: Optional[str] = Form(default=None),
) -> JSONResponse:
    """
    Full assistance pipeline (supports both video and image):
    1) Analyze video/image with Gemini to extract appliance/brand/issue/part_number/transcript
    2) Generate questions (extracted + clarifying)
    3) Retrieve support docs from Chroma (BGE-M3 embeddings), optionally filtered by part_number
    4) Ask Gemini to produce a grounded, actionable answer
    
    Supports:
    - Video files: MP4, WebM, MOV, AVI
    - Image files: JPG, JPEG, PNG, WebP, GIF
    - Video URLs: Direct links to video files
    """
    settings = get_settings()
    chosen_model = model or settings.gemini_model
    request_id = str(uuid.uuid4())
    t0 = time.perf_counter()

    if (video_file is None and not video_url) or (video_file is not None and video_url):
        raise HTTPException(status_code=400, detail="Provide exactly one of: video_file OR video_url")

    try:
        if video_file is not None:
            file_bytes = await video_file.read()
            payload = await read_upload(file_bytes, video_file.filename, max_bytes=settings.max_video_bytes)
        else:
            if video_url is None:
                raise HTTPException(status_code=400, detail="Provide video_url when video_file is not provided")
            payload = await download_video(video_url, max_bytes=settings.max_video_bytes)

        # Detect if media is an image
        is_image = payload.mime_type and payload.mime_type.startswith("image/")

        logger.info(
            "request_id=%s event=assist_media_received source=%s mime_type=%s bytes=%d model=%s is_image=%s",
            request_id,
            payload.source,
            payload.mime_type,
            len(payload.data),
            chosen_model,
            is_image,
        )

        # 1) Media analysis (video or image)
        result = analyze_video_with_gemini(
            api_key=settings.gemini_api_key,
            model=chosen_model,
            video_bytes=payload.data,
            video_mime_type=payload.mime_type,
            language=language,
            user_hint=user_hint,
            is_image=is_image,
        )
        analysis = result.data or {}
        transcript = analysis.get("transcript", "") or ""

        # 2) Questions
        user_questions = extract_user_questions(transcript)
        clarifying_questions = generate_clarifying_questions(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            language=language,
        )
        # 3) Retrieval
        queries = build_retrieval_queries(
            appliance_type=analysis.get("appliance_type"),
            brand_or_model=analysis.get("brand_or_model"),
            issue_summary=analysis.get("issue_summary"),
            user_questions=user_questions,
        )
        # Use part_number from request if provided, otherwise from video analysis
        effective_part_number = part_number if part_number and part_number.strip() else analysis.get("part_number")
        citations = retrieve_support_docs(queries, part_number=effective_part_number)

        # 4) Grounded answer
        grounded_prompt = compose_grounded_prompt(
            transcript=transcript,
            analysis=analysis,
            clarifying_questions=clarifying_questions,
            citations=citations,
            language=language,
            part_number=effective_part_number,
        )
        answer = answer_with_gemini(
            api_key=settings.gemini_api_key,
            model=settings.gemini_answer_model,
            prompt=grounded_prompt,
        )

        # 5) Generate audio from answer text
        audio_base64 = None
        audio_format = None
        if settings.elevenlabs_api_key:
            try:
                answer_text = answer.get("text", "")
                if answer_text:
                    audio_bytes, audio_format = text_to_speech_wav(
                        text=answer_text,
                        api_key=settings.elevenlabs_api_key,
                        language=language,
                    )
                    audio_base64 = base64.b64encode(audio_bytes).decode("utf-8")
                    logger.info("request_id=%s event=audio_generated format=%s", request_id, audio_format)
            except ElevenLabsTTSError as e:
                logger.warning("request_id=%s event=audio_generation_failed error=%s", request_id, str(e))
            except Exception as e:
                logger.warning("request_id=%s event=audio_generation_error error=%s", request_id, str(e))

        elapsed_ms = int((time.perf_counter() - t0) * 1000)
        logger.info("request_id=%s event=assist_pipeline_completed elapsed_ms=%d", request_id, elapsed_ms)

        # Prefer follow-up from analysis if any; otherwise suggest clarifying questions
        follow_ups = analysis.get("questions_to_confirm") or clarifying_questions

        response_content: Dict[str, Any] = {
            "ok": True,
            "request_id": request_id,
            "model_video": chosen_model,
            "model_answer": settings.gemini_answer_model,
            "video_source": payload.source,
            "video_mime_type": payload.mime_type,
            "analysis": analysis,
            "transcript": transcript,
            "user_questions": user_questions,
            "clarifying_questions": clarifying_questions,
            "retrieval": {"citations": citations},
            "answer": {
                "text": answer.get("text", ""),
                "follow_up_questions": follow_ups,
            },
            "raw_text_video": result.raw_text,
        }
        
        # Add audio fields if audio was generated
        if audio_base64:
            response_content["audio_base64"] = audio_base64
            response_content["audio_format"] = audio_format or "wav"

        return JSONResponse(
            status_code=200,
            content=response_content,
        )

    except VideoTooLargeError as e:
        logger.warning("request_id=%s event=video_too_large error=%s", request_id, str(e))
        raise HTTPException(status_code=413, detail=str(e)) from e
    except VideoDownloadError as e:
        logger.warning("request_id=%s event=video_download_failed error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=f"Failed to download video: {e}") from e
    except GeminiAPIError as e:
        logger.warning(
            "request_id=%s event=gemini_api_error status_code=%s retry_after_seconds=%s",
            request_id,
            e.status_code,
            e.retry_after_seconds,
        )
        detail: Dict[str, Any] = {"message": e.message}
        if e.retry_after_seconds is not None:
            detail["retry_after_seconds"] = e.retry_after_seconds
        raise HTTPException(status_code=e.status_code, detail=detail) from e
    except ValueError as e:
        logger.warning("request_id=%s event=bad_request error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/knowledge-base/documents")
async def add_document_to_kb(
    file: UploadFile = File(...),
    part_number: str = Form(...),
    name: Optional[str] = Form(None),
) -> JSONResponse:
    """
    Add new document to ElevenLabs Knowledge Base with part number.
    """
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    # Use write key for upload operations
    api_key = settings.get_elevenlabs_api_key_for_write()
    if not api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY or ELEVENLABS_API_KEY_WRITE is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required")
    
    try:
        # Read file
        file_bytes = await file.read()
        
        # Get MIME type from uploaded file
        mime_type = file.content_type
        
        # Upload to ElevenLabs KB
        result = upload_document_with_part_number(
            file_bytes=file_bytes,
            file_name=file.filename or "document",
            part_number=part_number,
            api_key=api_key,
            knowledge_base_id=kb_id,
            custom_name=name,
            mime_type=mime_type,
        )
        
        # Sync RAG index
        try:
            sync_rag_index(
                api_key=api_key,
                knowledge_base_id=kb_id,
                document_id=result["document_id"],
            )
        except Exception as e:
            logger.warning(f"Failed to sync RAG index: {e}")
        
        logger.info("request_id=%s event=document_uploaded doc_id=%s", request_id, result["document_id"])
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "document_id": result["document_id"],
                "name": result["name"],
                "part_number": result["part_number"],
            },
        )
        
    except ElevenLabsKBError as e:
        logger.warning("request_id=%s event=kb_upload_error error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/knowledge-base/documents/batch")
async def add_multiple_documents_to_kb(
    files: List[UploadFile] = File(...),
    part_number: str = Form(...),
    custom_names: Optional[str] = Form(None),
) -> JSONResponse:
    """
    Add multiple documents to ElevenLabs Knowledge Base with part number.
    All documents will be uploaded to the same folder (Part_{part_number}).
    
    Args:
        files: List of files to upload
        part_number: Part number for all documents
        custom_names: Optional comma-separated list of custom names (must match number of files)
    """
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    # Use write key for upload operations
    api_key = settings.get_elevenlabs_api_key_for_write()
    if not api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY or ELEVENLABS_API_KEY_WRITE is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required")
    
    if not files or len(files) == 0:
        raise HTTPException(status_code=400, detail="At least one file is required")
    
    # Parse custom names if provided
    custom_names_list = None
    if custom_names:
        custom_names_list = [name.strip() for name in custom_names.split(",")]
        if len(custom_names_list) != len(files):
            raise HTTPException(
                status_code=400,
                detail=f"Number of custom names ({len(custom_names_list)}) must match number of files ({len(files)})"
            )
    
    try:
        # Create or get folder for this part number
        folder_id = create_or_get_folder_by_part_number(api_key, part_number)
        if folder_id:
            logger.info(f"Using folder ID: {folder_id} for part number: {part_number}")
        else:
            logger.warning(f"Could not create/get folder for part number: {part_number}. Uploading without folder.")
        
        # Upload all files
        results = []
        failed_uploads = []
        
        for idx, file in enumerate(files):
            try:
                # Read file
                file_bytes = await file.read()
                
                # Get MIME type from uploaded file
                mime_type = file.content_type
                
                # Get custom name if provided
                custom_name = custom_names_list[idx] if custom_names_list else None
                
                # Upload to ElevenLabs KB
                result = upload_document_with_part_number(
                    file_bytes=file_bytes,
                    file_name=file.filename or f"document_{idx}",
                    part_number=part_number,
                    api_key=api_key,
                    knowledge_base_id=kb_id,
                    custom_name=custom_name,
                    mime_type=mime_type,
                    parent_folder_id=folder_id,
                )
                
                # Sync RAG index
                try:
                    sync_rag_index(
                        api_key=api_key,
                        knowledge_base_id=kb_id,
                        document_id=result["document_id"],
                    )
                except Exception as e:
                    logger.warning(f"Failed to sync RAG index for {file.filename}: {e}")
                
                results.append({
                    "file_name": file.filename,
                    "document_id": result["document_id"],
                    "name": result["name"],
                    "part_number": result["part_number"],
                    "status": "success",
                })
                
                logger.info(f"request_id={request_id} event=document_uploaded file={file.filename} doc_id={result['document_id']}")
                
            except ElevenLabsKBError as e:
                error_msg = str(e)
                failed_uploads.append({
                    "file_name": file.filename or f"document_{idx}",
                    "error": error_msg,
                    "status": "failed",
                })
                logger.warning(f"request_id={request_id} event=kb_upload_error file={file.filename} error={error_msg}")
            except Exception as e:  # noqa: BLE001
                error_msg = f"Internal error: {str(e)}"
                failed_uploads.append({
                    "file_name": file.filename or f"document_{idx}",
                    "error": error_msg,
                    "status": "failed",
                })
                logger.exception(f"request_id={request_id} event=internal_error file={file.filename}")
        
        # Assign Knowledge Base to Agent if agent_id is configured
        agent_assignment_result = None
        if settings.elevenlabs_agent_id and len(results) > 0:
            try:
                agent_assignment_result = assign_knowledge_base_to_agent(
                    api_key=api_key,
                    agent_id=settings.elevenlabs_agent_id,
                    knowledge_base_id=kb_id,
                )
                logger.info(f"request_id={request_id} event=kb_assigned_to_agent agent_id={settings.elevenlabs_agent_id} kb_id={kb_id}")
            except Exception as e:
                logger.warning(f"request_id={request_id} event=kb_assignment_failed error={str(e)}")
                agent_assignment_result = {
                    "status": "failed",
                    "error": str(e),
                    "note": "Please assign Knowledge Base to Agent manually via Dashboard",
                }
        
        response_content = {
            "ok": True,
            "request_id": request_id,
            "part_number": part_number,
            "folder_id": folder_id,
            "total_files": len(files),
            "successful_uploads": len(results),
            "failed_uploads": len(failed_uploads),
            "results": results,
            "failed": failed_uploads,
        }
        
        if agent_assignment_result:
            response_content["agent_assignment"] = agent_assignment_result
        
        return JSONResponse(
            status_code=200,
            content=response_content,
        )
        
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/knowledge-base/assign-to-agent")
async def assign_kb_to_agent() -> JSONResponse:
    """
    Assign Knowledge Base to Agent.
    This ensures the Agent can use the Knowledge Base for RAG.
    """
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    # Use write key for assignment operations
    api_key = settings.get_elevenlabs_api_key_for_write()
    if not api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY or ELEVENLABS_API_KEY_WRITE is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required")
    
    agent_id = settings.elevenlabs_agent_id
    if not agent_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_AGENT_ID is required")
    
    try:
        result = assign_knowledge_base_to_agent(
            api_key=api_key,
            agent_id=agent_id,
            knowledge_base_id=kb_id,
        )
        
        logger.info(f"request_id={request_id} event=kb_assigned_to_agent agent_id={agent_id} kb_id={kb_id}")
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "agent_id": agent_id,
                "knowledge_base_id": kb_id,
                "assignment": result,
            },
        )
        
    except ElevenLabsKBError as e:
        logger.warning(f"request_id={request_id} event=kb_assignment_error error={str(e)}")
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception(f"request_id={request_id} event=internal_error")
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.get("/knowledge-base/documents")
async def list_kb_documents(
    folder_name: Optional[str] = None,
    parent_folder_id: Optional[str] = None,
) -> JSONResponse:
    """List all documents in the Knowledge Base.
    
    Args:
        folder_name: Optional folder name to search for (e.g., "sm")
        parent_folder_id: Optional folder ID to list documents from specific folder
    """
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    # Use read key for listing documents
    api_key = settings.get_elevenlabs_api_key_for_read()
    if not api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY or ELEVENLABS_API_KEY_WRITE is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required")
    
    try:
        documents = list_documents(
            api_key=api_key,
            knowledge_base_id=kb_id,
            parent_folder_id=parent_folder_id,
            folder_name=folder_name,
        )
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "documents": documents,
                "count": len(documents),
            },
        )
        
    except ElevenLabsKBError as e:
        logger.warning("request_id=%s event=kb_list_error error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.delete("/knowledge-base/documents/{document_id}")
async def delete_kb_document(document_id: str) -> JSONResponse:
    """Delete a document from the Knowledge Base."""
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    # Use write key for delete operations
    api_key = settings.get_elevenlabs_api_key_for_write()
    if not api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY or ELEVENLABS_API_KEY_WRITE is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required")
    
    try:
        delete_document(
            api_key=api_key,
            knowledge_base_id=kb_id,
            document_id=document_id,
        )
        
        logger.info("request_id=%s event=document_deleted doc_id=%s", request_id, document_id)
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "document_id": document_id,
                "message": "Document deleted successfully",
            },
        )
        
    except ElevenLabsKBError as e:
        logger.warning("request_id=%s event=kb_delete_error error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/conversation/start")
async def start_conversation(
    video_analysis: str = Form(...),
    language: str = Form(default="ar"),
) -> JSONResponse:
    """Start a voice conversation session with ElevenLabs Agent."""
    import json
    
    settings = get_settings()
    request_id = str(uuid.uuid4())
    session_id = str(uuid.uuid4())
    
    if not settings.elevenlabs_api_key:
        raise HTTPException(status_code=400, detail="ELEVENLABS_API_KEY is required")
    
    if not settings.elevenlabs_agent_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_AGENT_ID is required")
    
    kb_id = settings.elevenlabs_knowledge_base_id
    if not kb_id:
        raise HTTPException(status_code=400, detail="ELEVENLABS_KNOWLEDGE_BASE_ID is required. Please create KB first.")
    
    try:
        analysis_data = json.loads(video_analysis)
        
        # Create conversation state
        conversation_state = ConversationState()
        conversation_state.set_video_context(analysis_data)
        
        # Initialize agent with video context
        agent_config = initialize_agent_with_video_context(
            agent_id=settings.elevenlabs_agent_id,
            knowledge_base_id=kb_id,
            api_key=settings.elevenlabs_api_key,
            video_analysis=analysis_data,
            language=language,
            conversation_state=conversation_state,
        )
        
        # Note: Actual conversation session creation happens on the client side
        # using the ElevenLabs SDK. This endpoint returns the configuration.
        
        logger.info("request_id=%s event=conversation_started session_id=%s", request_id, session_id)
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "session_id": session_id,
                "agent_config": {
                    "agent_id": agent_config["agent_id"],
                    "knowledge_base_id": agent_config["knowledge_base_id"],
                    "language": agent_config["language"],
                },
                "system_instructions": agent_config["system_instructions"],
                # Pass these to ElevenLabs session initiation (SDK/widget) so {{video_context}} is filled at runtime
                "dynamic_variables": agent_config.get("dynamic_variables", {}),
                "message": "Agent initialized. Use ElevenLabs SDK to start voice conversation.",
            },
        )
        
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=400, detail=f"Invalid video_analysis JSON: {e}") from e
    except ElevenLabsAgentError as e:
        logger.warning("request_id=%s event=agent_error error=%s", request_id, str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e


@app.post("/conversation/end")
async def end_conversation(
    session_id: str = Form(...),
    conversation_history: Optional[str] = Form(None),
) -> JSONResponse:
    """End a conversation session and get ticket summary."""
    import json
    
    settings = get_settings()
    request_id = str(uuid.uuid4())
    
    try:
        # Parse conversation history if provided
        history_data = None
        if conversation_history:
            try:
                history_data = json.loads(conversation_history)
            except json.JSONDecodeError:
                pass
        
        # Create conversation state from history
        conversation_state = ConversationState()
        if history_data:
            for msg in history_data.get("messages", []):
                conversation_state.add_message(
                    role=msg.get("role", "user"),
                    text=msg.get("text", ""),
                    citations=msg.get("citations", []),
                )
        
        conversation_state.ended = True
        
        # Get video context if available
        video_analysis = conversation_state.video_context
        
        # Generate ticket summary
        ticket_summary = generate_ticket_summary(
            conversation_state=conversation_state,
            video_analysis=video_analysis,
        )
        
        conversation_summary = conversation_state.get_conversation_summary()
        
        logger.info("request_id=%s event=conversation_ended session_id=%s", request_id, session_id)
        
        return JSONResponse(
            status_code=200,
            content={
                "ok": True,
                "request_id": request_id,
                "session_id": session_id,
                "ticket_summary": ticket_summary,
                "conversation_summary": conversation_summary,
            },
        )
        
    except HTTPException:
        raise
    except Exception as e:  # noqa: BLE001
        logger.exception("request_id=%s event=internal_error", request_id)
        raise HTTPException(status_code=500, detail=f"Internal error: {e}") from e

